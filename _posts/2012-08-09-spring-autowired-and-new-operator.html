---
layout: post
title: Spring @Autowired and the new operator
date: '2012-08-09T10:17:00.000+01:00'
author: David
tags: 
modified_time: '2012-08-09T10:17:23.083+01:00'
blogger_id: tag:blogger.com,1999:blog-2027514548288128942.post-8790621473285832872
blogger_orig_url: http://davidkerwick.blogspot.com/2012/08/spring-autowired-and-new-operator.html
---

So there I was happily shooting the breeze and added @Autowired to things like it was going out of fashion.&nbsp; But I then added it to a normal bean, which I was creating using the new operator in a RowMapper. Something like this<br /><pre class="prettyprint linenums">private static final class MyBeanMapper implements RowMapper<mybean> {<br /><br />  @Override<br />  public CapSumLineBean mapRow(ResultSet resultSet, int rowNum) throws SQLException {<br /><br />    MyBean myBean = new MyBean();<br />    myBean.setParam1(resultSet.getString("param1"));<br />    myBean.setParam1(resultSet.getString("param1"));<br />    return myBean;<br />  }<br />}<br /></mybean></pre>And MyBean looks something like<br /><pre class="prettyprint linenums">public class MyBean implements Serializable<br />{<br />    /** The Constant serialVersionUID. */ private static final long serialVersionUID = 2292124910377623287L;<br />    @Autowired private transient SomeUtil someUtil;<br />    private String param1;<br />    private String param2;<br />    public String getParam1<br />    {<br />        return someUtil.doSomething(this.param1);<br />    }<br />    public void setParam1(String param1)<br />    {<br />        this.param1 = param1;<br />    }<br />    public String getParam2<br />    {<br />        return this.param2;<br />    }<br />    public void setParam2(String param2)<br />    {<br />        this.param2 = param2;<br />    }<br />}<br /></pre>So when you call getParam1 you will get a NullPointerException because the @Autowired didn't do anything.&nbsp; It didn't do anything because this bean was created by me and not Spring and for @Autowired or any of its mates to work the bean must be Spring managed which something created by the new operator generally isn't.<br /><br /><h2>Getting MyBean Spring Managed</h2>So 'simple' solution, make the bean one that's managed by Spring.&nbsp; A bit of googling and&nbsp; I could create a factory class to produce these objects and tie that factory into Spring so the beans produced are Spring managed.&nbsp; That seems clunky to me at the time, it may be the best approach as I started down the rabbit hole with the next bit.<br /><br /><h3>It's easy just use @Configurable</h3>Found this<br />&nbsp;<a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-atconfigurable">http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-atconfigurable</a><br />Add an annotation and some config and Spring will catch the new operator operation and do it's magic, or something like that general Aspect Voodoo happens anyway.<br /><br />Right.... it's never that easy    I added @Configurable to MyBean    and added<br />&lt;context:spring-configured/&gt;  to my root-context.xml    and I get the error<br /><pre class="prettyprint linenums">Caused by: java.lang.ClassNotFoundException: org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect <br /></pre><br /><br />Time to check the dependencies  I already had<br /><br /><pre class="prettyprint linenums">&lt;dependency&gt;<br />  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;<br />  &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;<br />  &lt;version&gt;${org.aspectj-version}&lt;/version&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />  &lt;groupId&gt;cglib&lt;/groupId&gt;<br />  &lt;artifactId&gt;cglib&lt;/artifactId&gt;<br />  &lt;version&gt;${cglib.version}&lt;/version&gt;<br />&lt;/dependency&gt;</pre><pre class="prettyprint linenums">&nbsp;</pre>Which brought in spring-aop    So I added<br /><br /><pre class="prettyprint linenums">&lt;dependency&gt;<br />  &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />&nbsp; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;<br />&nbsp; &lt;version&gt;${org.springframework-version}&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre><br /><br />Which stopped the errors anyway<br />But still getting the NullPointerException<br />Found something which suggested adding in  <br />&lt;context:annotation-config /&gt;<br />Which did no harm but didn't solve anything<br />Next discovered was that @Configurable needs load time weaving, thought I had that I'm sure STS asked me about it, must have been compile time weaving?<br />Anyway I added in<br />&lt;context:load-time-weaver/&gt;<br />Which resulted in<br /><pre class="prettyprint linenums">Caused by: java.lang.IllegalStateException: ClassLoader [org.apache.catalina.loader.WebappClassLoader] does NOT provide an 'addTransformer(ClassFileTransformer)' method. Specify a custom LoadTimeWeaver or start your Java virtual machine with Spring's agent: -javaagent:org.springframework.instrument.jar<br /></pre><br />Turns out Tomcat isn't that happy about load time weaving    <br /><a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-aj-ltw-environments">http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/aop.html#aop-aj-ltw-environments</a><br />I got the jar from<br /><a href="http://mvnrepository.com/artifact/org.springframework/spring-instrument-tomcat">http://mvnrepository.com/artifact/org.springframework/spring-instrument-tomcat</a><br />And added it into  <span class="emphasis"><i>$CATALINA_HOME</i></span>/lib<br />I went blunderbuss and added<br /><pre class="prettyprint linenums">&lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader" /&gt;<br /></pre><br />to the Servers context.xml<br />Which lead to the error<br /><pre class="prettyprint linenums">java.lang.IllegalStateException: LifecycleProcessor not initialized - call 'refresh' before invoking lifecycle methods via the context <br /></pre><br />Well time to throw more dependencies at this so<br /><pre class="prettyprint linenums">&lt;dependency&gt;<br />&nbsp;&nbsp;&nbsp; &lt;groupId&gt;org.aspectj&lt;/groupId&gt;<br />&nbsp;&nbsp;&nbsp; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;<br />&nbsp;&nbsp;&nbsp; &lt;version&gt;${org.aspectj-version}&lt;/version&gt;<br />&lt;/dependency&gt;<br /><br /></pre>And it works!    <br /><h3>Conclusion</h3>Once setup with the dependencies and config elements @Configurable should just work like the rest of the magic annotations all be it there's more Aspect Voodoo going on.&nbsp; All in all it might be worth considering the factory option but this should be cleaner... I probably need to revisit the config and take out what's not needed and I just started adding things in to try get it to work.